<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" width="965" height="400"
				styleName="background" applicationComplete="init()" xmlns:local="*">
	<mx:Style source="assets/style.css"/>
	<mx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSON;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.core.UIComponent;
			import mx.effects.Fade;
			import mx.effects.Move;
			import mx.events.EffectEvent;
			import mx.managers.PopUpManager;
			import mx.rpc.events.ResultEvent;
			
			import uk.co.soulwire.cv.MotionTracker;
			
			var itemManager:ItemManager = new ItemManager();
			var frontBeltEllipse:Ellipse = new Ellipse();
			var backBeltEllipse:Ellipse = new Ellipse();
			var dummyBeltEllipse:Ellipse = new Ellipse();
			var itemsInFrontBelt:ArrayCollection = new ArrayCollection();
			var itemsInBackBelt:ArrayCollection = new ArrayCollection();
			var moveEffectOfFork:Move = new Move();
			var totalScore:int = 0;
			var remainingTime:int;
			var mainTimer:Timer;
			
			const MAIN_TIMER_INTERVAL:int = 10;
			const SPEED_CHANGE_AFTER:int = 3000;
			var mainTimerCounter:int = 0;
			
			public static var instance:NoodleRoulette;
			
			function init() {
				instance = this;
				
				this.frontBeltEllipse.center = new Point(gamePlayArea.width / 2, gamePlayArea.height / 2);
				this.frontBeltEllipse.a = gamePlayArea.width / 2 + 200;
				this.frontBeltEllipse.b = 140;
				
				this.backBeltEllipse.center = new Point(gamePlayArea.width / 2, gamePlayArea.height / 2);
				this.backBeltEllipse.a = gamePlayArea.width / 2 + 100;
				this.backBeltEllipse.b = 40;
				
				this.dummyBeltEllipse.center = new Point(gamePlayArea.width / 2, gamePlayArea.height / 2 + 50);
				this.dummyBeltEllipse.a = this.backBeltEllipse.a;
				this.dummyBeltEllipse.b = this.backBeltEllipse.b;
				
				this.moveEffectOfFork.target = fork;
				
				var controlModeSelectionPopup:ControllModeSelectionPopup = new ControllModeSelectionPopup();
				centerUIComponent(this, controlModeSelectionPopup);
				PopUpManager.addPopUp(controlModeSelectionPopup, this, false);
				
				updateHighscoreList();				
			}
			
			public function updateHighscoreList() {
				hightscoreList.removeAllChildren();
				httpGetHightScoreList.send(null);
			}
			
			public static function centerUIComponent(parentUI:UIComponent, child:UIComponent) {
				child.x = parentUI.width/2 - child.width/2;
				child.y = parentUI.height/2 - child.height/2;
			}
			
			public function startRoullete():void {
				remainingTime = 5 * 1000;
				mainTimer = new Timer(MAIN_TIMER_INTERVAL, 0);
				mainTimer.addEventListener(TimerEvent.TIMER, onTimer);
				mainTimer.start();
			}
			
			public function stopGame() {
				mainTimer.stop();
				disableCurrentMode();
				itemManager.stopAll();
			}
			
			var lastDummyItem;
			function onTimer(event:TimerEvent) {
				mainTimerCounter += MAIN_TIMER_INTERVAL;
				if (mainTimerCounter > SPEED_CHANGE_AFTER) {
					mainTimerCounter = 0;
					var rate:Number = Math.random() + 0.3;
					itemManager.setSpeedRate(rate);
				}
				
				//handle remaining time
				remainingTime -= MAIN_TIMER_INTERVAL;
				if (remainingTime <= 0) {
					stopGame();
					var userInformationPopup:UserInformationPopup = new UserInformationPopup();
					centerUIComponent(this, userInformationPopup);
					PopUpManager.addPopUp(userInformationPopup, this, false);
					return;
				}
				var min:int = remainingTime / (60 * 1000);
				var sec:int = (remainingTime - min * 60 * 1000) / 1000;
				time.text = (min < 10 ? "0" : "") + min + ":" + (sec < 10 ? "0" : "") + sec;
				
				
				//handle back belt
				if (itemsInFrontBelt.length > 0) {
					var firstItem:Item = itemsInFrontBelt.getItemAt(0) as Item;
					if (!firstItem.isUsed()) {
						itemsInFrontBelt.removeItemAt(0);
						itemsInBackBelt.addItem(firstItem);
						initForBackBelt(firstItem.moveEffect);
						firstItem.moveEffect.start();
					}
				}
				
				//handle front belt
				var needNewItem:Boolean = false;
				if (itemsInFrontBelt.length == 0) {
					needNewItem = true;
				} else {
					var lastItem:Item = itemsInFrontBelt.getItemAt(itemsInFrontBelt.length - 1) as Item;
					if (Math.abs(lastItem.moveEffect.x - lastItem.moveEffect.fromX) > 100) {
						needNewItem = true;
					}
				}

				if (needNewItem) {
					var item:Item = itemManager.allocateItem(getRandomIdx());
					gamePlayArea.addChild(item.image);
					itemsInFrontBelt.addItem(item);
					initForFrontBelt(item.moveEffect);
					item.moveEffect.start();
				}
				
				//handle dummy belt
				needNewItem = false;
				if (lastDummyItem == null || Math.abs(lastDummyItem.moveEffect.x - lastDummyItem.moveEffect.fromX) > 100) {
					var dummyItem:Item = itemManager.allocateItem(getRandomIdx());
					gamePlayArea.addChild(dummyItem.image);
					lastDummyItem = dummyItem;
					initForDummyBelt(dummyItem.moveEffect);
					dummyItem.moveEffect.start();
				}
			}
			
			public function getRandomIdx():int {
				return Math.floor(Math.random() * 10);
			}
			
			public function initForFrontBelt(ellipseMove:EllipseMove):EllipseMove {
				return ellipseMove.init(ellipseMove.move.target, frontBeltEllipse.center, 
					frontBeltEllipse.a, frontBeltEllipse.b, 
					-frontBeltEllipse.a, frontBeltEllipse.a);
			}
			
			public function initForBackBelt(ellipseMove:EllipseMove):EllipseMove {
				return ellipseMove.init(ellipseMove.move.target, backBeltEllipse.center, 
					backBeltEllipse.a, backBeltEllipse.b, 
					backBeltEllipse.a, -backBeltEllipse.a,
					true);
			}
			
			public function initForDummyBelt(ellipseMove:EllipseMove):EllipseMove {
				return ellipseMove.init(ellipseMove.move.target, dummyBeltEllipse.center, 
					dummyBeltEllipse.a, dummyBeltEllipse.b, 
					-dummyBeltEllipse.a, dummyBeltEllipse.a,
					true, true);
			}
			
			public function moveForkHorizontally(xBy:int):void {
				this.moveEffectOfFork.stop();
				this.moveEffectOfFork.xBy = xBy;
				this.moveEffectOfFork.yBy = 0;
				this.moveEffectOfFork.duration = 100;
				this.moveEffectOfFork.play();
			}
			
			public function forkDown():void {
				this.disableCurrentMode();
				this.moveEffectOfFork.stop();
				var forkDownEffect:Move = new Move();
				forkDownEffect.target = fork;
				forkDownEffect.xBy = 0;
				forkDownEffect.yBy = 200;
				forkDownEffect.duration = 300;
				forkDownEffect.addEventListener(EffectEvent.EFFECT_END,
					function(event:EffectEvent) {
						var moveEffectOfForkAndItem:Move = new Move();
						moveEffectOfForkAndItem.duration = 500;
						var caughtItem:Item;
						for (var i:int = 0; i < itemsInFrontBelt.length; i++) {
							var item:Item = itemsInFrontBelt.getItemAt(i) as Item;
							if (isCaught(item.image)) {
								itemsInFrontBelt.removeItemAt( itemsInFrontBelt.getItemIndex(item) );
								item.moveEffect.freeze();
								if (gamePlayArea.getChildIndex(item.image) >= 0) {
									gamePlayArea.removeChild(item.image);
								}
								addChild(item.image);
								
								moveEffectOfForkAndItem.targets = new Array(fork, item.image);
								caughtItem = item;
								break;
							}
						}
						if (caughtItem != null) {
							moveEffectOfForkAndItem.xBy = ((bowl.x + bowl.width/2) - fork.width/2) - fork.x;
							moveEffectOfForkAndItem.yBy = -fork.y;
							var isMEOFAIEnded:Boolean = false;
							moveEffectOfForkAndItem.addEventListener(EffectEvent.EFFECT_END,
								function(event:Event) {
									if (isMEOFAIEnded) {
										return;
									}
									isMEOFAIEnded = true;
									initCurrentMode();
									var dropItemEffect:Move = new Move();
									dropItemEffect.target = caughtItem.image;
									dropItemEffect.duration = 500;
									dropItemEffect.yBy = 100;
									dropItemEffect.addEventListener(EffectEvent.EFFECT_END,
										function(event:Event) {
											var disappear:Fade = new Fade();
											disappear.target = caughtItem.image;
											disappear.alphaFrom = 1;
											disappear.alphaTo = 0;
											disappear.duration = 300;
											disappear.addEventListener(EffectEvent.EFFECT_END, 
												function(event:Event) {
													caughtItem.moveEffect.unfreeze();
													totalScore += caughtItem.score;
													score.text = totalScore.toString();
													caughtItem = null;
												}
											);
											
											disappear.play();
										}
									);
									dropItemEffect.play();
								}
							);
						} else {
							moveEffectOfForkAndItem.target = fork;
							moveEffectOfForkAndItem.yBy = -fork.y;
							moveEffectOfForkAndItem.addEventListener(EffectEvent.EFFECT_END,
								function(event:Event) {
									initCurrentMode();	
									caughtItem = null;
								}
							);
						}
						moveEffectOfForkAndItem.play();
					}
				);
				forkDownEffect.play();
			}
			
			function isCaught(target:UIComponent):Boolean {
				var forkRect:Rectangle = fork.getRect(this);
				var targetRect:Rectangle = new Rectangle(target.x + target.width / 6, target.y, target.width * 2 / 3, target.height);
				
				if (!forkRect.intersects(targetRect)) return false;
				
				var intersect:Rectangle = forkRect.intersection(targetRect);
				return intersect.width >= forkRect.width / 2;
			}
			
//			public function isOverlap(obj1:UIComponent, obj2:UIComponent):Boolean {
//				var rect1:Rectangle = new Rectangle(obj1.x, obj1.y, obj1.width, obj1.height);
//				var rect2:Rectangle = new Rectangle(obj2.x, obj2.y, obj2.width, obj2.height);
//				return rect1.intersects(rect2);
//			}
			
			public const CONTROL_MODE_KEYBOARD = 1;
			public const CONTROL_MODE_MOUSE = 2;
			public const CONTROL_MODE_WEBCAM = 3;
			var controlMode:int;
			
			public function initKeyboardMode() {
				controlMode = CONTROL_MODE_KEYBOARD;
				stage.addEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown);
			}
			public function disableKeyboardMode() {
				stage.removeEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown);
			}
			
			public function initMouseMode() {
				controlMode = CONTROL_MODE_MOUSE;
				stage.addEventListener(MouseEvent.CLICK, handleMouseClick);
				stage.addEventListener(MouseEvent.MOUSE_MOVE, handleMouseMove);
					
			}
			public function disableMouseMode() {
				stage.removeEventListener(MouseEvent.CLICK, handleMouseClick);
				stage.removeEventListener(MouseEvent.MOUSE_MOVE, handleMouseMove);
			}
			
			var motionTracker:MotionTracker;
			var motionTrackerTimer:Timer;
			var lastMotionTrackerY:Number;
			public function initWebcamMode() {
				controlMode = CONTROL_MODE_WEBCAM;
				if (motionTracker == null && motionTrackerTimer == null) {
					var camW : int = gamePlayArea.width;
					var camH : int = gamePlayArea.height;
					
					// Create the camera
					var cam : Camera = Camera.getCamera();
					cam.setMode(camW, camH, stage.frameRate);
					
					// Create a video
					var vid : Video = new Video(camW, camH);
					vid.attachCamera(cam);
					
					// Create the Motion Tracker
					motionTracker = new MotionTracker(vid);
					
					motionTrackerTimer = new Timer(100, 0);
					motionTrackerTimer.addEventListener(TimerEvent.TIMER,
						function(event:Event) {
							// Tell the MotionTracker to update itself
							motionTracker.track();
							
							// If there is enough movement (see the MotionTracker's minArea property) then continue
							if ( !motionTracker.hasMovement ) return;
							
							var motionX:Number = motionTracker.motionArea.x + motionTracker.motionArea.width / 2;
							var motionY:Number = motionTracker.motionArea.y + motionTracker.motionArea.height / 2;
							
							// Move the target with some easing
							moveEffectOfFork.stop();
							moveEffectOfFork.xTo = gamePlayArea.x + gamePlayArea.width - motionX;
							moveEffectOfFork.yTo = 0;
							moveEffectOfFork.play();
//							if (Math.abs(gamePlayArea.y + gamePlayArea.height - motionY) < 100) {
//								forkDown();
//							}
							if (motionY > 300) {
								forkDown();
							}
						}
					);
					motionTrackerTimer.start();
				} else {
					motionTrackerTimer.start();
				}
			}
			public function disableWebcamMode() {
				motionTrackerTimer.stop();
			}
			
			public function initCurrentMode() {
				if (controlMode == CONTROL_MODE_KEYBOARD) {
					initKeyboardMode();
				} else if (controlMode == CONTROL_MODE_MOUSE) {
					initMouseMode();
				} else if (controlMode == CONTROL_MODE_WEBCAM) {
					initWebcamMode();
				}
			}
			public function disableCurrentMode() {
				if (controlMode == CONTROL_MODE_KEYBOARD) {
					disableKeyboardMode();
				} else if (controlMode == CONTROL_MODE_MOUSE) {
					disableMouseMode();
				} else if (controlMode == CONTROL_MODE_WEBCAM) {
					disableWebcamMode();
				}
			}
			
			public function handleKeyDown(event:KeyboardEvent):void {
				if (event.keyCode == 39) { //RIGHT
					moveForkHorizontally(20);
				} else if (event.keyCode == 37) {//LEFT	
					moveForkHorizontally(-20);
				} else if (event.keyCode == 40) {//DOWN
					forkDown();
				}
			}
			
			function handleMouseClick(event:MouseEvent):void {
				forkDown();
			}
			function handleMouseMove(event:MouseEvent):void {
				if ( gamePlayArea.getRect(this).contains(event.stageX, event.stageY) ) {
					fork.x = event.stageX;
				}
			}
			
			function finishGetHighScoreList(event:ResultEvent) {
				var JSONResArr:String = String(httpGetHightScoreList.lastResult);
				if (JSONResArr != null && JSONResArr.length > 0) {
					var arrHighscore:Array = JSON.decode(JSONResArr);
					if (arrHighscore != null) {
						for (var i:int = 0; i < arrHighscore.length; i++) {
							var hs = arrHighscore[i];
							
							var txtFullname:Label = new Label();
							txtFullname.text = hs.fullname;
							txtFullname.x = 0;
							txtFullname.y = i * 30;
							hightscoreList.addChild(txtFullname);
							
							var txtScore:Label = new Label();
							txtScore.text = hs.score;
							txtScore.x = 100;
							txtScore.y = i * 30;
							hightscoreList.addChild(txtScore);
						}
					}
				}
			}
		]]>
	</mx:Script>
	
	<mx:Canvas id="gamePlayArea" x="18" y="9" width="704" height="383" 
			   horizontalScrollPolicy="off" verticalScrollPolicy="off">
	</mx:Canvas>
	
	<mx:Image id="bowl" source="@Embed(source='assets/girls.png')" x="250" y="110"/>
	
	<mx:Label id="score" x="310" y="245" width="100" styleName="score" text="0" textAlign="center"/>
	
	<mx:Image id="fork" source="@Embed(source='assets/fork.png')"/>	
	<mx:Canvas id="clock" x="596" y="10" backgroundImage="@Embed(source='assets/clock.png')" width="98" height="46">
		<mx:Label id="time" text="00:00" styleName="time"/>
	</mx:Canvas>
	
	<local:NoCachingHttpService
		id="httpGetHightScoreList"
		url="http://mekongmedia.com.vn/reeva3mien/highscore.php"
		method="GET"
		resultFormat="object"
		result="finishGetHighScoreList(event)"
		/>
	<mx:Canvas id="hightscoreList" x="755" y="110" width="200" height="200"
			   verticalScrollPolicy="auto" horizontalScrollPolicy="off">
	</mx:Canvas>
	
</mx:Application>

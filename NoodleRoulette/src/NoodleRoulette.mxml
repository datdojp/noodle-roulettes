<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" width="965" height="400"
				styleName="background" applicationComplete="init()">
	<mx:Style source="assets/style.css"/>
	<mx:Script>
		<![CDATA[
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.controls.Image;
			import mx.core.UIComponent;
			import mx.effects.Fade;
			import mx.effects.Move;
			import mx.events.EffectEvent;
			import mx.managers.PopUpManager;
			
			var itemManager:ItemManager = new ItemManager();
			var frontBeltEllipse:Ellipse = new Ellipse();
			var backBeltEllipse:Ellipse = new Ellipse();
			var dummyBeltEllipse:Ellipse = new Ellipse();
			var itemsInFrontBelt:ArrayCollection = new ArrayCollection();
			var itemsInBackBelt:ArrayCollection = new ArrayCollection();
			var moveEffectOfFork:Move = new Move();
			var totalScore:int = 0;
			
			public static var instance:NoodleRoulette;
			
			function init() {
				instance = this;
				
				this.frontBeltEllipse.center = new Point(gamePlayArea.width / 2, gamePlayArea.height / 2);
				this.frontBeltEllipse.a = gamePlayArea.width / 2 + 200;
				this.frontBeltEllipse.b = 140;
				
				this.backBeltEllipse.center = new Point(gamePlayArea.width / 2, gamePlayArea.height / 2);
				this.backBeltEllipse.a = gamePlayArea.width / 2 + 100;
				this.backBeltEllipse.b = 40;
				
				this.dummyBeltEllipse.center = new Point(gamePlayArea.width / 2, gamePlayArea.height / 2 + 50);
				this.dummyBeltEllipse.a = this.backBeltEllipse.a;
				this.dummyBeltEllipse.b = this.backBeltEllipse.b;
				
				this.moveEffectOfFork.target = fork;
				
				var controlModeSelectionPopup:ControllModeSelectionPopup = new ControllModeSelectionPopup;
				centerUIComponent(this, controlModeSelectionPopup);
				PopUpManager.addPopUp(controlModeSelectionPopup, this, false);
			}
			
			public static function centerUIComponent(parentUI:UIComponent, child:UIComponent) {
				child.x = parentUI.width/2 - child.width/2;
				child.y = parentUI.height/2 - child.height/2;
			}
			
			public function startRoullete():void {
				var mainTimer:Timer = new Timer(10, 0);
				mainTimer.addEventListener(TimerEvent.TIMER, onTimer);
				mainTimer.start();
			}
			
			var lastDummyItem;
			function onTimer(event:TimerEvent) {
				//handle back belt
				if (itemsInFrontBelt.length > 0) {
					var firstItem:Item = itemsInFrontBelt.getItemAt(0) as Item;
					if (!firstItem.isUsed()) {
						itemsInFrontBelt.removeItemAt(0);
						itemsInBackBelt.addItem(firstItem);
						initForBackBelt(firstItem.moveEffect);
						firstItem.moveEffect.start();
					}
				}
				
				//handle front belt
				var needNewItem:Boolean = false;
				if (itemsInFrontBelt.length == 0) {
					needNewItem = true;
				} else {
					var lastItem:Item = itemsInFrontBelt.getItemAt(itemsInFrontBelt.length - 1) as Item;
					if (Math.abs(lastItem.moveEffect.x - lastItem.moveEffect.fromX) > 200) {
						needNewItem = true;
					}
				}

				if (needNewItem) {
					var item:Item = itemManager.allocateItem(getRandomIdx());
					gamePlayArea.addChild(item.image);
					itemsInFrontBelt.addItem(item);
					initForFrontBelt(item.moveEffect);
					item.moveEffect.start();
				}
				
				//handle dummy belt
				needNewItem = false;
				if (lastDummyItem == null || Math.abs(lastDummyItem.moveEffect.x - lastDummyItem.moveEffect.fromX) > 100) {
					var dummyItem:Item = itemManager.allocateItem(getRandomIdx());
					gamePlayArea.addChild(dummyItem.image);
					lastDummyItem = dummyItem;
					initForDummyBelt(dummyItem.moveEffect);
					dummyItem.moveEffect.start();
				}
			}
			
			public function getRandomIdx():int {
				return Math.floor(Math.random() * 10);
			}
			
			public function initForFrontBelt(ellipseMove:EllipseMove):EllipseMove {
				return ellipseMove.init(ellipseMove.move.target, frontBeltEllipse.center, 
					frontBeltEllipse.a, frontBeltEllipse.b, 
					-frontBeltEllipse.a, frontBeltEllipse.a);
			}
			
			public function initForBackBelt(ellipseMove:EllipseMove):EllipseMove {
				return ellipseMove.init(ellipseMove.move.target, backBeltEllipse.center, 
					backBeltEllipse.a, backBeltEllipse.b, 
					backBeltEllipse.a, -backBeltEllipse.a,
					true);
			}
			
			public function initForDummyBelt(ellipseMove:EllipseMove):EllipseMove {
				return ellipseMove.init(ellipseMove.move.target, dummyBeltEllipse.center, 
					dummyBeltEllipse.a, dummyBeltEllipse.b, 
					-dummyBeltEllipse.a, dummyBeltEllipse.a,
					true, true);
			}
			
			public function outDebug(content:String) {
				this.debug.text = content;
			}
			
			public function moveForkHorizontally(xBy:int):void {
				this.moveEffectOfFork.stop();
				this.moveEffectOfFork.xBy = xBy;
				this.moveEffectOfFork.yBy = 0;
				this.moveEffectOfFork.duration = 100;
				this.moveEffectOfFork.play();
			}
			
			public function forkDown():void {
				this.disableCurrentMode();
				this.moveEffectOfFork.stop();
				var forkDownEffect:Move = new Move();
				forkDownEffect.target = fork;
				forkDownEffect.xBy = 0;
				forkDownEffect.yBy = 200;
				forkDownEffect.duration = 300;
				forkDownEffect.addEventListener(EffectEvent.EFFECT_END,
					function(event:EffectEvent) {
						var moveEffectOfForkAndItem:Move = new Move();
						moveEffectOfForkAndItem.duration = 500;
						var caughtItem:Item;
						for (var i:int = 0; i < itemsInFrontBelt.length; i++) {
							var item:Item = itemsInFrontBelt.getItemAt(i) as Item;
							if (isOverlap(item.image, fork)) {
								itemsInFrontBelt.removeItemAt( itemsInFrontBelt.getItemIndex(item) );
								item.moveEffect.freeze();
								if (gamePlayArea.getChildIndex(item.image) >= 0) {
									gamePlayArea.removeChild(item.image);
								}
								addChild(item.image);
								
								moveEffectOfForkAndItem.targets = new Array(fork, item.image);
								caughtItem = item;
								break;
							}
						}
						if (caughtItem != null) {
							moveEffectOfForkAndItem.xBy = ((bowl.x + bowl.width/2) - fork.width/2) - fork.x;
							moveEffectOfForkAndItem.yBy = -fork.y;
							var isMEOFAIEnded:Boolean = false;
							moveEffectOfForkAndItem.addEventListener(EffectEvent.EFFECT_END,
								function(event:Event) {
									if (isMEOFAIEnded) {
										return;
									}
									isMEOFAIEnded = true;
									initCurrentMode();
									var dropItemEffect:Move = new Move();
									dropItemEffect.target = caughtItem.image;
									dropItemEffect.duration = 500;
									dropItemEffect.yBy = 100;
									dropItemEffect.addEventListener(EffectEvent.EFFECT_END,
										function(event:Event) {
											var disappear:Fade = new Fade();
											disappear.target = caughtItem.image;
											disappear.alphaFrom = 1;
											disappear.alphaTo = 0;
											disappear.duration = 300;
											disappear.addEventListener(EffectEvent.EFFECT_END, 
												function(event:Event) {
													caughtItem.moveEffect.unfreeze();
													totalScore += caughtItem.score;
													score.text = totalScore.toString();
													caughtItem = null;
												}
											);
											
											disappear.play();
										}
									);
									dropItemEffect.play();
								}
							);
						} else {
							moveEffectOfForkAndItem.target = fork;
							moveEffectOfForkAndItem.yBy = -fork.y;
							moveEffectOfForkAndItem.addEventListener(EffectEvent.EFFECT_END,
								function(event:Event) {
									initCurrentMode();	
									caughtItem = null;
								}
							);
						}
						moveEffectOfForkAndItem.play();
					}
				);
				forkDownEffect.play();
			}
			
			public function isOverlap(obj1:UIComponent, obj2:UIComponent):Boolean {
				var rect1:Rectangle = new Rectangle(obj1.x, obj1.y, obj1.width, obj1.height);
				var rect2:Rectangle = new Rectangle(obj2.x, obj2.y, obj2.width, obj2.height);
				return rect1.intersects(rect2);
			}
			
			public const CONTROL_MODE_KEYBOARD = 1;
			public const CONTROL_MODE_MOUSE = 2;
			public const CONTROL_MODE_WEBCAM = 3;
			var controlMode:int;
			
			public function initKeyboardMode() {
				controlMode = CONTROL_MODE_KEYBOARD;
				stage.addEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown);
			}
			public function disableKeyboardMode() {
				stage.removeEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown);
			}
			
			public function initMouseMode() {
				controlMode = CONTROL_MODE_MOUSE;
				stage.addEventListener(MouseEvent.CLICK, handleMouseClick);
				stage.addEventListener(MouseEvent.MOUSE_MOVE, handleMouseMove);
					
			}
			public function disableMouseMode() {
				stage.removeEventListener(MouseEvent.CLICK, handleMouseClick);
				stage.removeEventListener(MouseEvent.MOUSE_MOVE, handleMouseMove);
			}
			
			public function initWebcamMode() {
				controlMode = CONTROL_MODE_WEBCAM;
				//TODO
			}
			public function disableWebcamMode() {
				//TODO
			}
			
			public function initCurrentMode() {
				if (controlMode == CONTROL_MODE_KEYBOARD) {
					initKeyboardMode();
				} else if (controlMode == CONTROL_MODE_MOUSE) {
					initMouseMode();
				} else if (controlMode == CONTROL_MODE_WEBCAM) {
					initWebcamMode();
				}
			}
			public function disableCurrentMode() {
				if (controlMode == CONTROL_MODE_KEYBOARD) {
					disableKeyboardMode();
				} else if (controlMode == CONTROL_MODE_MOUSE) {
					disableMouseMode();
				} else if (controlMode == CONTROL_MODE_WEBCAM) {
					disableWebcamMode();
				}
			}
			
			public function handleKeyDown(event:KeyboardEvent):void {
				if (event.keyCode == 39) { //RIGHT
					moveForkHorizontally(20);
				} else if (event.keyCode == 37) {//LEFT	
					moveForkHorizontally(-20);
				} else if (event.keyCode == 40) {//DOWN
					forkDown();
				}
			}
			
			function handleMouseClick(event:MouseEvent):void {
				forkDown();
			}
			function handleMouseMove(event:MouseEvent):void {
				if ( gamePlayArea.getRect(this).contains(event.stageX, event.stageY) ) {
					fork.x = event.stageX;
				}
			}
		]]>
	</mx:Script>
	
	<mx:Canvas id="gamePlayArea" x="18" y="9" width="704" height="383" 
			   horizontalScrollPolicy="off" verticalScrollPolicy="off">
	</mx:Canvas>
	
	<mx:Label id="debug" x="760" y="39" text="Label"/>
	
	<mx:Image id="bowl" source="@Embed(source='assets/girls.png')" x="250" y="110"/>
	
	<mx:Label id="score" x="310" y="245" width="100" styleName="score" text="0" textAlign="center"/>
	
	<mx:Image id="fork" source="@Embed(source='assets/fork.png')"/>	
</mx:Application>
